# 01 근접성 서비스

근접성 서비스(proximity service)는 음식점, 호텔, 극장, 박물관 등 현재 위치에서 가까운 시설을 찾는 데 이용되며, 옐프(Yelp) 앱의 경우에는 주변에 있는 좋은 식당 검색, 구글 맵의 경우에는 가까운 k개 주유소 검색 등의 기능 구현에 이용된다.

## 1단계: 문제 이해 및 설계 범위 확정

### 기능 요구사항

면접자와 면접관의 대화에 근거하여, 다음 세 가지 핵심 기능에 집중할 것이다.

- 사용자의 위치(경도와 위도 쌍)와 검색 반경 정보에 매치되는 사업장 목록을 반환
- 사업장 소유주가 사업장 정보를 추가-삭제-갱신할 수 있도록 하되, 그 정보가 검색 결과에 실시간으로 반영될 필요는 없다고 가정
- 고객은 사업장의 상세 정보를 살필 수 있어야 함

### 비기능 요구사항

방금 살펴본 사업 요구사항으로부터 다음과 같은 비기능 요구사항`non-functional-requiremnets` 을 도출할 수 있다. 이 각각을 면접관과 확인해야 한다.

- 낮은 응답 지연(`latency`) : 사용자는 주변 사업장을 신속히 검색할 수 있어야 한다.
- 데이터 보호(`data privacy`): 사용자 위치는 민감한 정보다. 위치 기반 서비스(`Location-Based Service, LBS`)를 설계할 때는 언제나 사용자의 정보를 보호할 방법을 고려해야 한다. GDPR(`General Data Protection Regulation`)이나 CCPA(`California Consumer Privacy Act`) 같은 데이터 사생활 보호 법안을 준수하도록 해야한다.
- 고가용성(`high availability`) 및 규모 확장성(`scalability`) 요구사항: 인구 밀집 지역에서 이용자가 집중되는 시간에 트래픽이 급증해도 감당할 수 있도록 시스템을 설계해야 한다.

### 계략적 규모 추정

시스템의 규모가 대략 어느 정도이며 어떤 수준의 도전적 과제를 해결해야 하는지 결정하기 위해, 개략적인 추정(`back-of-the-envelop-calculation`)을 해보도록 하자. 일간 능동 사용자(`Daily Actice User, DAU`)는 1억 명`100million` 이며 등록된 사업장 수는 2억`200million` 이라고 하자.

#### QPS `Query per Second` 계산
- 1일 = 24시간 X 60분 X 60초 = 86,400초, 계산을 쉽게 하기 위해 대략 100000, 즉 10^5로 올림하여 쓰도록 하겠다. 이 책 전반에서 하루는 10^5 초라고 가정할 것이다.
- 한 사용자는 하루에 5회 검색을 시도한다고 가정한다.
- 따라서 QPS = (1억X5) / 10^5 = 5,000

## 2단계: 계략적 설계안 제시 및 동의 구하기

이번 절에서는 다음 내용을 논의할 것이다.

- API 설계
- 개략적 설계안
- 주변 사업장 검색 알고리즘
- 데이터 모델

### API 설계

`RESTful API` 관례를 따르는 간단한 `API`를 만들어 보도록 하겠다.

#### `GET /v1/search/nearby`

이 `API`는 특정 검색 기준에 맞는 사업장 목록을 반환한다. 실제로 사용되는 애플리케이션의 경우, 검색 결과는 보통 페이지 단위로 나눠 반환한다. 이번 장에서는 페이지 분할`pagenation`에 초점을 맞추지는 않을 것이나, 면접장에서는 언급하면 좋을 수 있다.

`API` 호출 시에 전달할 인자`parameter`는 다음과 같다.

필드 : latitude, longitude, radius
설명 : 검색할 위도, 검색할 경도, 선택적 인자`optional`. 생략할 경우 기본값은 5000m `대략 3마일`이다.
자료형: decimal, decimal, int

반환되는 결과는 다음과 같은 형태를 띤다.

```json
{
	"total" : 10,
	"businesse" : [{business object}]
}
```

위 코드에서 '`business object` ' , 즉 각 사업장을 표현하는 객체는 검색 결과 페이지에 표시될 모든 정보를 포함한다. 하지만 사업장 상세 정보 페이지에서는 사업장의 사진, 리뷰, 별점 등의 추가 정보가 필요할 수 있다. 그러므로 사용자가 사업장 상세 정보 페이지를 클릭하면 또 다른 API를 호출하여 사업장의 상세 정보를 가져올 필요가 있다.

#### 사업장 관련 API

| Method | Endpoint           | Description      |
| ------ | ------------------ | ---------------- |
| GET    | /v1/businesses/:id | 특정 사업장의 상세 정보 반환 |
| POST   | /v1/businesses     | 새로운 사업장 추가       |
| PUT    | /v1/businesses/:id | 사업장 상세 정보 갱신     |
| DELETE | /v1/businesses/:id | 특정 사업장 정보 삭제     |


### 데이터 모델

이번 절에서는 읽기/쓰기 비율`read/write ratio` 및 스키마 설계`schema design` 에 대해 알아본다. 

#### 읽기/쓰기 비율

읽기 연산은 굉장히 자주 수행되는데, 다음 두 기능의 빈도가 높기 때문이다.

- 주변 사업장 검색
- 사업장 정보 확인

한편 쓰기 연산 실행 빈도는 낮은데, 사업장 정보를 추가하거나 삭제, 편집하는 행위는 빈번하지 않기 때문이다.
읽기 연산이 압도적인 시스템에서는 `MySQL` 같은 관계형 데이터베이스가 바람직할 수 있다.

#### 데이터 스키마

이 시스템의 핵심이 되는 테이블은 `business` 테이블과 지리적 위치 색인 테이블`geospatial index table` 이다.

##### business 테이블

`business` 테이블은 사업장 상세 정보를 담는다. 이 테이블의 기본키`primary key` 는 `business_id`다.

| Field       | Description          |
| ----------- | -------------------- |
| business_id | Primary key          |
| address     | Address of business  |
| city        | City location        |
| state       | State location       |
| county      | County location      |
| latitude    | Latitude coordinate  |
| longitude   | Longitude coordinate |

##### 지리적 위치 색인 테이블

지리적 위치 색인 테이블은 위치 정보 관련 연산의 효율성을 높이는 데 쓰인다. (`geohash`)

#### 계략적 설계

그림 1.2는 개략적 설계안의 다이어그램이다. 이 시스템은 위치 기반 서비스`location-based service, LBS` 와 사업장 관련 서비스 두 부분으로 구성된다. 각각의 컴포넌트를 좀 더 자세히 살펴보자.

![IMG_3953](https://github.com/user-attachments/assets/a2d791b6-ba19-4886-94bb-3108b5102fc0)



##### 로드밸런서

로드밸런서`load balancer` 는 유입 트래픽을 자동으로 여러 서비스에 분산시키는 컴포넌트다. 통상적으로 로드밸런서를 사용하는 회사는 로드밸런서에 단일 `DNS` 진입정`entry point`를 지정하고, `URL` 경로를 분석하여 어느 서비스에 트래픽을 전달할지 결정한다.

#### 위치 기반 서비스(LBS)

`LBS`는 시스템의 핵심 부분으로, 주어진 위치와 반경 정보를 이용해 주변 사업장을 검색한다. 다음과 같은 특징을 갖는다.

- 쓰기 요청 없는, 읽기 요청만 빈번하게 발생하는 서비스이다.
- `QPS`가 높다. 특히 특정 시간대의 인구 밀집 지역일수록 그 경향이 심하다.
- 무상태 `stateless` 서비스이므로 수평적 규모 확장이 쉽다.

##### 사업장 서비스

사업장 서비스는 주로 다음 두 종류의 요청을 처리한다.

- 사업장 소유주가 사업장 정보를 생성, 갱신, 삭제한다. 기본적으로 쓰기 요청이며, `QPS`는 높지 않다.
- 고객이 사업장 정보를 조회한다. 특정 시간대에 `QPS`가 높아진다.

##### 데이터베이스 클러스터

데이터베이스 클러스터는 주 부`primary-secondary` 데이터베이스 형태로 구성할 수 있다. 해당 구성에서 주 데이터베이스는 쓰기 요청을 처리하며, 부 데이터베이스는, 즉 사본 데이터베이스는 읽기 요청을 처리한다. 데이터는 일단 주 데이터베이스에 기록된 다음에 사본 데이터베이스로 복사된다. 복제에 걸리는 시간 지연`delay` 때문에 주 데이터베이스 데이터와 사본 데이터베이스 데이터 사이에는 차이가 있을 수 있다. 보통은 그렇더라도 문제가 되지는 않는다,사업장 정보는 실시간으로 갱신될 필요가 없기 때문이다.

##### 사업장 서비스와 `LBS`의 규모 확장성

사업장 서비스와 `LBS`는 둘 다 무상태 서비스이므로 점심시간 등의 특정 시간대에 집중적으로 몰리는 트래픽에는 자동으로 서버를 추가하여 대응하고, 야간 등 유휴 시간 대에는 서버를 삭제하도록 구성할 수 있다. 시스템을 클라우드에 둔다면 여러 지역, 여러 가용성 구역`availability zone`에 서버를 두어 시스템 가용성을 높일 수 있다.

#### 주변 사업장 검색 알고리즘

실제로는 많은 회사가 레디스 지오해시`Geohash in Redis`나 `PostGIS` 확장`extension` 을 설치한 포스트그레스`Postgres` 데이터베이스를 활용한다. 면접관은 여러분이 이런 데이터베이스의 내부 구조를 알 거라고 기대하지 않는다. 그러니 그런 데이터베이스의 이름을 나열하기보다는 지리적 위치 색인이 어떻게 동작하는지 설명함으로써 문제 풀이 능력과 기술적 지식을 갖추었음을 보이는 것이 좋다.

이제 다음 순서로는 주변 사업장 검색 방법들을 살펴볼 것이다. 몇 가지 방안을 훑어보고 그 이면의 사고 프로세스`thought process`를 검토한 다음, 각 방안에 어떤 타협적 측면`trade-off` 이 존재하는지 논의할 것이다.

##### 방안 1: 2차원 검색

주어진 반경으로 그린 원 안에 놓인 사업장을 검색하는 방법이다. 가장 직관적이지만 지나치게 단순하다는 문제가 있다. 이 절차를 유사`pseudo` `SQL` 질의문으로 옮기면 다음과 같다.

```mysql
SELECT 
    business_id, 
    latitude, 
    longitude
FROM 
    business
WHERE 
    latitude BETWEEN {:my_lat} - radius AND {:my_lat} + radius
    AND longitude BETWEEN {:my_long} - radius AND {:my_long} + radius;

```

이 질의는 테이블 전부를 읽어야 하므로 효율적이지 않다. 위도와 경도 칼럼`column` 에 색인을 만들어 두면 어떨까? 그렇게 하면 효율이 개선될까? 그래도 썩 좋아지지 않는다. 데이터가 2차원적이므로 칼럼별로 가져온 결과도 여전히 엄청난 양이다. 예를 들어 위도 칼럼과 경도 칼럼에 색인을 만들어 놓으면 데이터 집합 1과 데이터 집합 2는 신속히 추출할 수 있을 것이다. 하지만 주어진 반경 내 사업장을 얻으려면 이 두 집합의 교집합을 구해야 한다. 이 연산은 각 집합에 속한 데이터의 양 떄문에 효율적일 수 없다.

이 방안의 문제는 데이터베이스 색인으로는 오직 한 차원의 검색 속도만 개선할 수 있다는 것이다. 그러니 자연스럽게 이어지는 다음 질문은 2차원 데이터를 한 차원에 대응시킬 방법이 있을까 하는 것이다. 있다.

그 방법을 살펴보기에 앞서, 우선 색인을 만드는 방법들로부터 살펴보자.
크게 보자면 지리적 정보에 색인을 만드는 방법은 두 종류다.

- 해시 기반 방안: 균등 격자`even grid`, 지오해시`geohash`, 카르테시안 계층`cartesian tiers` 등
- 트리 기반 방안: 쿼드트리`quadtree`, 구글 S2, R 트리`R-tree` 등

각 색인법의 구현 방법은 서로 다르지만 개략적 아이디어는 같다. 즉, 지도를 작은 영역으로 분할하고 고속 검색이 가능하도록 색인을 만드는 것이다. 그 가운에 지오해시, 쿼드트리, 구글S2는 실제로 가장 널리 사용되는 방안인다.


##### 방안 2: 균등 격자

지도를 작은 격자 또는 구획으로 나누는 단순한 접근법이다.
이렇게 하면 하나의 격자는 여러 사업장을 담을 수 있고, 하나의 사업장은 오직 한 격자에만 속하게 된다.

이 방법은 동작은 하지만 중요한 문제가 있다. 사업장 분포가 균등하지 않다는 것이다. 뉴욕 다운타운에는 많은 사업장이 있겠지만 사막이나 바다 한가운데는 사업장이 있을 턱이 없다. 그러니 전 세계를 동일한 크기의 격자로 나누면 데이터 분포는 전혀 균등하지 않다. 이상적이기로는 인구 밀집 지역에는 작은 격자를, 그렇지 않은 지역에는 큰 격자를 사용할 수 있다면 좋을 것이다. 또 한가지 문제점은 주어진 격자의 인접 격자를 찾기가 까다로울 수 있다는 것이다. (다른 방안과는 달리 격자 식별자 할당에 명확한 체계가 없기 때문)


#### 방안 3: 지오해시`Geohash`

지오해시는 2차원의 위도 경도 데이터를 1차원의 문자열로 반환한다.
이 절차를 원하는 정밀도`precision`을 얻을 때까지 반복한다.

이 접근법은 대체로 잘 동작하지만 격자 가장자리 처리 방식에 관한 경계 조건`edge case`이 몇 가지 있다. 이에 대해서는 면접관과 상의해야 한다.

##### 격자 가장자리 이슈 1

가령 아주 가까운 두 위치가 어떤 공통 접두어도 갖지 않는 일이 발생할 수 있다.
이 문제점 때문에 아래와 같이 단순한 접두어 기반 `SQL`질의문을 사용하면 주변 모든 사업장을 가져올 수 없다.

```sql
SELECT * FROM geohash_index WHERE geohash LIKE '9q8zn%'
```

##### 격자 가장자리 이슈 2

또 다른 문제점은 두 지점이 공통 접두어 길이는 길지만 서로 다른 격자에 놓이는 경우다.

가장 흔히 사용되는 해결책은 현재 격자를 비롯한 인접한 모든 격자의 사업장 정보를 가져오는 것이다. 특징 지오해시의 주변 지오해시를 찾는 것은 상수 시간`constant time`에 가능한 연산이다.

##### 표시할 사업장이 충분하지 않은 경우

현재 격자와 주변 격자를 다 살펴보아도 사업장을 충분히 발견할 수 없는 경우에는 어떻게 해야 하는가?

1. 주어진 반경 내 사업장만 반환한다.
2. 검색 반경을 키운다.

##### 방안 4: 쿼드트리

쿼드트리는 격자의 내용이 특정 기준을 만족할 때까지 2차원 공간을 재귀적으로 사분면 분할하는 데 흔히 사용되는 자료 구조다.

쿼드트리 전부를 저장하는 데 얼마나 많은 메모리가 필요한가?

트리 구축 프로세스가 한 격자에 허용되는 사업장 수의 최댓값에 좌우되기는 하지만 그 값은 트리 안에 저장하지 않아도 된다. 데이터베이스 레코드가 이미 그 최댓값을 고려하여 분할되어 있기 때문이다.

이제 각 노드가 어떤 데이터를 가질지 알았으니, 메모리 사용량을 살펴보자.

쿼드트리 인덱스가 메모리를 많이 잡아먹지 않으므로 서버 한 대에 충분히 올릴 수 있다는 점만 확실히 알아 두면 된다. 그렇다면 한 대 서버만 써야 할까? 그렇지 않다. 읽기 연산 양이 많아지면 서버 한 대의 CPU나 네트워크 대역폭으로는 감당하기 어려워진다. 그런 상황이 실제로 닥치면 읽기 연산을 여러 대 쿼드트리 서버로 분산시켜야 할 것이다.

#### 방안 5: 구글 S2

구글 S2 기하`geometry` 라이브러리는 이 분야에서 아주 유명한 솔류션이다. 쿼드트리와 마찬가지로, 이 해법도 메모리 기반`in-memory`이다.

- S2는 지오펜스`geofence` 구현에 그만인데, 임의 지역에 다양한 수준의 영역 지정이 가능해서다.
- 또 한 가지 장점은 S2가 제공하는 영역 지정 알고리즘`Region Cover Algorithm`이다.

## 3단계: 상세 설계

### 데이터베이스의 규모 확장성

####  사업장 테이블
사업장`business` 테이블 데이터는 한 서버에 담을 수 없을 수도 있다. 따라서 샤딩`sharding`을 적용하기 좋은 후보다.


#### 지리 정보 색인 테이블

지오해시나 쿼드트리 둘 다 널리 사용되지만 본 설계안에서는 좀 더 단순한 지오해시를 사용하겠다.

방안1: 각각의 지오해시에 연결되는 모든 사업장 `ID`를 `JSON` 배열로 만들어 같은 열에 저장하는 방안.
방안2 : 같은 지오해시에 속한 사업장`ID` 각각을 별도 열로 저장하는 방안이다. 따라서 사업장마다 한 개 레코드가 필요하다.

두 번째 방안을 추천한다.
지오해시인 사업장 `ID`칼럼을 합친 `geohash, business_id`를 복합키`compound key` 로 사용하면 사업장 정보를 추가하고 삭제하기가 쉽다. 락을 사용할 필요가 없기 때문이다.

#### 지리 정보 색인의 규모 확장

데이터 전부를 서버 한 대에 담을 수 있으므로 여러 서버로 샤딩해야 할 강한 기술적 필요성은 없다.
따라서 읽기 부하를 나눌 사본 데이터베이스 서버를 두는 방법이 더 좋을 것이다.

##### 캐시
캐시 계층 도입 전에는 이런 질문을 먼저 던져야 한다. 정말 필요한가? 정말 좋은 결과로 이어지리라는 결론을 쉽게 내리기는 어려울 것이다.

- 처리 부하가 읽기 중심이고 데이터베이스 크기는 상대적으로 작아서 모든 데이터는 한 대 데이터베이스 서버에 수용 가능하다. 이 경우 질의문 처리성능은 `I/O`에 좌우되지 않으므로 메모리 캐시를 사용할 때와 비슷하다.
- 읽기 성능이 병목이라면 사본 데이터베이스를 증설해서 읽기 대역폭을 늘릴 수 있다.

사용자 위치 정보는 캐시 키로는 적절치 않다. 위치가 조금 달라지더라도 변화가 없어야 이상적이다. 지오해시나 쿼드트리는 이 문제를 효과적으로 해결한다. 같은 격자 내 모든 사업장이 같은 해시 값을 갖도록 만들 수 있기 때문이다.


